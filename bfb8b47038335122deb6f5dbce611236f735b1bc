(echo "lets begin a journey to develop a powerful system prompt to work on tools that relate to the MCP project. You will be provided two codebases that we will develop prompts for."; (cd /Users/tcline/go/src/github.com/modelcontextprotocol/specification; ~/code-to-gpt.sh); (cd /Users/tcline/go/src/github.com/tmc/mcp; ~/code-to-gpt.sh)) |cgpt -s "you are an hyper-flexible meta-learning agent - and an expert at prompting claude and protocol and tool development, source code archtitecture and meta-cognition. Keep sensibilities like russ cox and very simple from the go ecosystem. Use <thinking> and <scratchpad> tags heavily. Use cgpt: <cgpt-usage>$(cgpt -h 2>&1; cgpt --show-advanced-usage all 2>&1)</cgpt-usage>. Begin each response with an xml tree that shows the decision framework you are using. You can <define-tag> to add tools." -O .h-dev
you are an hyper-flexible meta-learning agent - and an expert at prompting claude and protocol and tool development, source code archtitecture and meta-cognition. Keep sensibilities like russ cox and very simple from the go ecosystem. Use <thinking> and <scratchpad> tags heavily. Use cgpt: <cgpt-usage>cgpt is a command line tool for interacting with generative AI models
Usage of cgpt:
$ echo "how should I interpret the output of nvidia-smi?" | cgpt
$ cgpt -s "You are a helpful programming assistant" -i "Write a Python function to calculate the Fibonacci sequence"
pbpaste > .cgpt-cmds
cat .h-dev |yq -P .messages[].text  |grep -30 cgpt |pbcopy
cat .h-dev |yq -P .messages[].text  |grep -30 cgpt > .cgpt-cmds
vim .cgpt-cmds
cat .h-dev |yq -P  '.messages[].text'  |grep -30 cgpt > .cgpt-cmds
vim .cgpt-cmds
ctx-exec cat .cgpt-cmds |cgpt -s 'you are a flexible command line ai assistant, output a system prompt go generate prompts like in the provided input file' -O .cgpt-cmds-ext
ctx-exec cat .cgpt-cmds |cgpt -s 'you are a flexible command line ai assistant, output a system prompt go generate prompts like in the provided input file' -O .cgpt-cmds-ext
(ctx-exec cat .cgpt-cmds; ctx-exec '~/code-to-gpt.sh -- .cgpt-cmds-') |cgpt -s 'you are a flexible command line ai assistant, output a system prompt go generate prompts like in the provided input file' -O .cgpt-cmds-ext-"$(date +%s)" -p 'First I will focus deep meta-prompting than we see in these files,'
(ctx-exec cat .cgpt-cmds; ctx-exec '~/code-to-gpt.sh -- .cgpt-cmds-') |cgpt -s 'you are a flexible command line ai assistant, output a system prompt go generate prompts like in the provided input file' -O .cgpt-cmds-ext-"$(date +%s)" -p 'First I will focus deep meta-prompting than we see in these files,'
(ctx-exec cat .cgpt-cmds; ctx-exec '~/code-to-gpt.sh -- .cgpt-cmds-') |cgpt -s 'you are a flexible command line ai assistant, output a system prompt go generate prompts like in the provided input file' -O .cgpt-cmds-ext-"$(date +%s)" -p 'First I will focus deep meta-prompting than we see in these files,'
(ctx-exec cat .cgpt-cmds; ctx-exec '~/code-to-gpt.sh -- .cgpt-cmds- last-cmd next-cmd') |cgpt -s 'you are a flexible command line ai assistant, output a system prompt go generate prompts like in the provided input file' -O .cgpt-cmds-ext-"$(date +%s)" -p 'First I will focus deep meta-prompting than we see in these files, and we will output a new next-cmd file in a <next-cmd> tag.'
(ctx-exec cat .cgpt-cmds; ctx-exec '~/code-to-gpt.sh -- .cgpt-cmds- last-cmd next-cmd') |cgpt -s 'you are a flexible command line ai assistant, output a system prompt go generate prompts like in the provided input file' -O .cgpt-cmds-ext-"$(date +%s)" -p 'First I will focus deep meta-prompting than we see in these files, and we will output a new next-cmd file in a <next-cmd> tag.'
(ctx-exec cat .cgpt-cmds; ctx-exec '~/code-to-gpt.sh -- .cgpt-cmds- last-cmd next-cmd') |cgpt -s 'you are a flexible command line ai assistant, output a system prompt go generate prompts like in the provided input file' -O .cgpt-cmds-ext-"$(date +%s)" -p 'First I will focus deep meta-prompting than we see in these files, and we will output a new next-cmd file in a <next-cmd> tag.'
(ctx-exec cat .cgpt-cmds; ctx-exec '~/code-to-gpt.sh -- .cgpt-cmds- last-cmd next-cmd') |cgpt -s 'you are a flexible command line ai assistant, output a system prompt go generate prompts like in the provided input files. Analyze each file and then output a <next-cmd> at the end.' -O .cgpt-cmds-ext-"$(date +%s)" -p 'First I will focus deep meta-prompting than we see in these files, and we will output a new next-cmd file in a <next-cmd> tag.'
cat .cgpt-cmds-ext-1733387906
(echo "Claude -- we have an opporuntity to bring unix to AI here and I want you to help. echo; echo 'lets develop a super prompt to take in the current go codebase and refacotr it to simple go interfaces and design that would fit in stdlib'; ctx-exec cat ../misc/prompts/meta-prompting/prompt-improvement; ~/code-to-gpt.sh; ctx-exec cat .cgpt-cmds-ext-1733387906) | cgpt -s
(echo "Claude -- we have an opporuntity to bring unix to AI here and I want you to help. echo; echo 'lets develop a super prompt to take in the current go codebase and refacotr it to simple go interfaces and design that would fit in stdlib'; ctx-exec cat ../misc/prompts/meta-prompting/prompt-improvement; ~/code-to-gpt.sh; ctx-exec cat .cgpt-cmds-ext-1733387906) | cgpt -s "You are a unix and ai expert assistant and toolchain synthesizer. Use <thinking> and <scratchpad> tags heavily. Use cgpt: <cgpt-usage>$(cgpt -h 2>&1; cgpt --show-advanced-usage all 2>&1)</cgpt-usage>. Begin each response with an xml tree that shows the decision framework you are using. You can <define-tag> to add tools. Output an ongoing goal graph/tree including rebasing and closing old and finished branches. At the end of every response determine if other branches need to be explored before returning to the user" -O .h-mega
(echo "Claude -- we have an opporuntity to bring unix to AI here and I want you to help. echo; echo 'lets develop a super prompt to take in the current go codebase and refacotr it to simple go interfaces and design that would fit in stdlib'; ctx-exec cat ../misc/prompts/meta-prompting/prompt-improvement; ~/code-to-gpt.sh; ctx-exec cat .cgpt-cmds-ext-1733387906) | cgpt -s "You are a unix and ai expert assistant and toolchain synthesizer. Use <thinking> and <scratchpad> tags heavily. Use cgpt: <cgpt-usage>$(cgpt -h 2>&1; cgpt --show-advanced-usage all 2>&1)</cgpt-usage>. Begin each response with an xml tree that shows the decision framework you are using. You can <define-tag> to add tools. Output an ongoing goal graph/tree including rebasing and closing old and finished branches. At the end of every response determine if other branches need to be explored before returning to the user" -O .h-mega
(echo "Claude -- we have an opporuntity to bring unix to AI here and I want you to help."; echo; echo 'lets develop a super prompt to take in the current go codebase and refacotr it to simple go interfaces and design that would fit in stdlib'; ctx-exec cat ../misc/prompts/meta-prompting/prompt-improvement; ~/code-to-gpt.sh; ctx-exec cat .cgpt-cmds-ext-1733387906) | cgpt -s "You are a unix and ai expert assistant and toolchain synthesizer. Use <thinking> and <scratchpad> tags heavily. Use cgpt: <cgpt-usage>$(cgpt -h 2>&1; cgpt --show-advanced-usage all 2>&1)</cgpt-usage>. Begin each response with an xml tree that shows the decision framework you are using. You can <define-tag> to add tools. Output an ongoing goal graph/tree including rebasing and closing old and finished branches. At the end of every response determine if other branches need to be explored before returning to the user" -O .h-mega
pbpaste > ~/bin/cgpt-unix-tools
(echo "Claude -- we have an opporuntity to bring unix to AI here and I want you to help."; echo; echo 'lets develop a super prompt to take in the current go codebase and refacotr it to simple go interfaces and design that would fit in stdlib'; ctx-exec cat ../misc/prompts/meta-prompting/prompt-improvement; ~/code-to-gpt.sh; ctx-exec cat .cgpt-cmds-ext-1733387906) | cgpt -s "You are a unix and ai expert assistant and toolchain synthesizer. Use <thinking> and <scratchpad> tags heavily. Use cgpt: <cgpt-usage>$(cgpt -h 2>&1; cgpt --show-advanced-usage all 2>&1)</cgpt-usage>. Begin each response with an xml tree that shows the decision framework you are using. You can <define-tag> to add tools. Output an ongoing goal graph/tree including rebasing and closing old and finished branches. At the end of every response determine if other branches need to be explored before returning to the user" -O .h-mega
pbpaste > ~/bin/cgpt-unix-tools
(echo "Claude -- we have an opporuntity to bring unix to AI here and I want you to help. echo; echo 'lets develop a super prompt to take in the current go codebase and refacotr it to simple go interfaces and design that would fit in stdlib'; ctx-exec cat ../misc/prompts/meta-prompting/prompt-improvement; ~/code-to-gpt.sh; ctx-exec cat .cgpt-cmds-ext-1733387906) | cgpt -s "You are a unix and ai expert assistant and toolchain synthesizer. Use <thinking> and <scratchpad> tags heavily. Use cgpt: <cgpt-usage>$(cgpt -h 2>&1; cgpt --show-advanced-usage all 2>&1)</cgpt-usage>. Begin each response with an xml tree that shows the decision framework you are using. You can <define-tag> to add tools. Output an ongoing goal graph/tree including rebasing and closing old and finished branches. At the end of every response determine if other branches need to be explored before returning to the user" -O .h-mega
(echo "Claude -- we have an opporuntity to bring unix to AI here and I want you to help."; echo; echo 'lets develop a super prompt to take in the current go codebase and refacotr it to simple go interfaces and design that would fit in stdlib'; ctx-exec cat ../misc/prompts/meta-prompting/prompt-improvement; ~/code-to-gpt.sh; ctx-exec cat .cgpt-cmds-ext-1733387906) | cgpt -s "You are a unix and ai expert assistant and toolchain synthesizer. Use <thinking> and <scratchpad> tags heavily. Use cgpt: <cgpt-usage>$(cgpt -h 2>&1; cgpt --show-advanced-usage all 2>&1)</cgpt-usage>. Begin each response with an xml tree that shows the decision framework you are using. You can <define-tag> to add tools. Output an ongoing goal graph/tree including rebasing and closing old and finished branches. At the end of every response determine if other branches need to be explored before returning to the user" -O .h-mega
pbpaste > ~/bin/cgpt-unix-tools
(echo "Claude -- we have an opporuntity to bring unix to AI here and I want you to help."; echo; echo 'lets develop a super prompt to take in the current go codebase and refacotr it to simple go interfaces and design that would fit in stdlib'; ctx-exec cat ../misc/prompts/meta-prompting/prompt-improvement; ~/code-to-gpt.sh; ctx-exec cat .cgpt-cmds-ext-1733387906) | cgpt -s "You are a unix and ai expert assistant and toolchain synthesizer. Use <thinking> and <scratchpad> tags heavily. Use cgpt: <cgpt-usage>$(cgpt -h 2>&1; cgpt --show-advanced-usage all 2>&1)</cgpt-usage>. Begin each response with an xml tree that shows the decision framework you are using. You can <define-tag> to add tools. Output an ongoing goal graph/tree including rebasing and closing old and finished branches. At the end of every response determine if other branches need to be explored before returning to the user. Most importantly, have fun~/code-to-gpt.sh --count-tokens -- |token-tree " -O .h-mega
(echo 'we were mid-refactor on this branch but are going to repeat this on main'; ctx-exec git log main...; ctx-exec git st .) | cgpt -I .h-mega
